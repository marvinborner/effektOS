import debug
import panic

// ISA IRQs
record TimerTick()
record PS2Keyboard()
record Cascade()
record COM2()
record COM1()
record LPT2()
record FloppyDisk()
record LPT1()
record CMOS()
record Peripheral1()
record Peripheral2()
record Peripheral3()
record PS2Mouse()
record FPU()
record PrimaryATA()
record SecondaryATA()

interface Request {
  def trap(n: Int): Unit
  def event(n: Int): Unit
  def special(n: Int): Unit
}

record Fault(num: Int)

def show(fault: Fault) = fault.num match {
  case 0  => "Division Error"
  case 1  => "Debug"
  case 2  => "Non-maskable Interrupt"
  case 3  => "Breakpoint"
  case 4  => "Overflow"
  case 5  => "Bound Range Exceeded"
  case 6  => "Invalid Opcode"
  case 7  => "Device Not Available"
  case 8  => "Double Fault"
  case 9  => "Coprocessor Segment Overrun"
  case 10 => "Invalid TSS"
  case 11 => "Segment Not Present"
  case 12 => "Stack-Segment Fault"
  case 13 => "General Protection Fault"
  case 14 => "Page Fault"
  case 15 => "Reserved"
  case 16 => "x87 Floating-Point Exception"
  case 17 => "Alignment Check"
  case 18 => "Machine Check"
  case 19 => "SIMD Floating-Point Exception"
  case 20 => "Virtualization Exception"
  case 21 => "Control Protection Exception"
  case 22 => "Reserved"
  case 23 => "Reserved"
  case 24 => "Reserved"
  case 25 => "Reserved"
  case 26 => "Reserved"
  case 27 => "Reserved"
  case 28 => "Hypervisor Injection Exception"
  case 29 => "VMM Communication Exception"
  case 30 => "Security Exception"
  case 31 => "Reserved"
  case _  => "Unknown"
}

interface Interrupt[I] {
  def interrupt(interrupt: I): Unit
}

def dispatch { prog: => Nothing / Request }: Nothing / {
  Interrupt[TimerTick], Interrupt[PS2Keyboard], Interrupt[Cascade], Interrupt[COM2], Interrupt[COM1],
  Interrupt[LPT2], Interrupt[FloppyDisk], Interrupt[LPT1], Interrupt[CMOS], Interrupt[Peripheral1],
  Interrupt[Peripheral2], Interrupt[Peripheral3], Interrupt[PS2Mouse], Interrupt[FPU], Interrupt[PrimaryATA],
  Interrupt[SecondaryATA], Debug
} = {
  try prog()
  with Request {
    def trap(n: Int) = {
      do println("IT'S A TRAP: this should have been handled!")
      hcf()
    }
    def event(n: Int) = resume(n match {
      case 0  => do interrupt(TimerTick())
      case 1  => do interrupt(PS2Keyboard())
      case 2  => do interrupt(Cascade())
      case 3  => do interrupt(COM2())
      case 4  => do interrupt(COM1())
      case 5  => do interrupt(LPT2())
      case 6  => do interrupt(FloppyDisk())
      case 7  => do interrupt(LPT1())
      case 8  => do interrupt(CMOS())
      case 9  => do interrupt(Peripheral1())
      case 10 => do interrupt(Peripheral2())
      case 11 => do interrupt(Peripheral3())
      case 12 => do interrupt(PS2Mouse())
      case 13 => do interrupt(FPU())
      case 14 => do interrupt(PrimaryATA())
      case 15 => do interrupt(SecondaryATA())
      case _  => do println("unknown event: ${n.show}")
    })
    def special(n: Int) = n match {
      case _ => resume(do println("unknown special ${n.show}"))
    }
  }
}

def handle[I, E] { handle: => Unit / emit[E] } { prog: => Nothing / Interrupt[I] }: Nothing / emit[E] =
  try { prog() } with Interrupt[I] { def interrupt(interrupt: I) = resume(handle()) }

def ignore[I] { prog: => Nothing / Interrupt[I] }: Nothing =
  try { prog() } with Interrupt[I] { def interrupt(interrupt: I) = resume(()) }

def report[I] { prog: => Nothing / Interrupt[I] }: Nothing =
  try { prog() } with Interrupt[I] { def interrupt(exception: I) = resume(report("interrupt\n")) }

def panicOn[I, T] { prog: => T / Interrupt[I] }: T =
  try { prog() } with Interrupt[I] { def interrupt(interrupt: I) = panic("panic") }

record on[I]()

def handle[I, E](proxy: on[I]) { d: => Unit / emit[E] } { prog: => Nothing / Interrupt[I] }: Nothing / emit[E] =
  handle[I, E] {d} {prog}

def ignore[I](proxy: on[I]) { prog: => Nothing / Interrupt[I] }: Nothing =
  ignore[I] {prog}

def report[I](proxy: on[I]) { prog: => Nothing / Interrupt[I] }: Nothing =
  report[I] {prog}

def panic[I, T](proxy: on[I]) { prog: => T / Interrupt[I] }: T =
  panicOn[I, T] {prog}