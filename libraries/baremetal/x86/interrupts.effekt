import interrupt
import framebuffer
import x86/pic
import x86/commands

extern llvm """
  declare %Pos @c_idt_init()
  declare %Pos @c_install_exception_handler(%Pos)
  declare %Pos @c_install_interrupt_handler(%Pos)
"""

extern def installExceptionHandler(callback: Int => Nothing at {io, global}) at {io}: Unit =
  llvm """
    call void @c_install_exception_handler(%Pos ${callback})
    ret %Pos zeroinitializer
  """

extern def installInterruptHandler(callback: Int => Unit at {io, global}) at {io}: Unit =
  llvm """
    call void @c_install_interrupt_handler(%Pos ${callback})
    ret %Pos zeroinitializer
  """

extern def initIDT() at {io}: Unit =
  llvm """
    call void @c_idt_init()
    ret %Pos zeroinitializer
  """

def newHandler(inbox: Ref[List[Int]]): Int => Unit at {io, global} = {
  val handler: Int => Unit at {io, global} = box { i =>
    installInterruptHandler(inbox.newHandler())
    inbox.set(Cons(i, inbox.get))
    pic::ack(i)
  }
  handler
}

def init(exception: Int => Nothing at {io, global}): Ref[List[Int]] = {
  initIDT()

  val inbox = ref[List[Int]](Nil())
  installExceptionHandler(exception)
  installInterruptHandler(inbox.newHandler)
  inbox
}

// inspired by the react-ish framework by @jiribenes
def idle(inbox: Ref[List[Int]]) at {io, global}: Nothing / Request = {
  halt() // until interrupt

  val interrupts = inbox.get.reverse
  inbox.set(Nil())

  if (interrupts.nonEmpty) {
    interrupts.foreach { int =>
      if (int < 32) {
        do trap(int)
      } else if (int < 48) {
        do event(int - 32)
      } else if (int >= 128) {
        do special(int - 128)
      }
    }
  }

  idle(inbox)
}
